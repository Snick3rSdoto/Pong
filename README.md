# Pong SFML

Невелика 2D-гра, написана на **C++** з використанням **SFML**.  
Проєкт задуманий як демонстрація:

- сучасного C++ (класи, ООП, розумні вказівники, STL),
- базової архітектури ігрового рушія (ігровий цикл, розділення логіки та відмальовки),
- використання зовнішньої графічної бібліотеки (SFML),
- патерну проектування Strategy.

---
Target platforms: Ubuntu 16.04/18.04 x64  
Developed and tested on a PC running Ubuntu 24.04.3 LTS (64-bit).

---

## Геймплей

Класична схема Pong:

- Ліва ракетка — **гравець**, керування:  
  - `W` — вгору  
  - `S` — вниз  
- Права ракетка — **опонент (AI)**. Вона намагається тримати свій центр на рівні м’яча, рухається повільніше за гравця.
- М’яч рухається по діагоналі, відбивається від верхньої та нижньої межі екрану, а також від ракеток.
- Якщо м’яч «пролітає» повз ракетку та виходить за ліву/праву межу:
  - зараховується гол відповідному гравцю,
  - м’яч скидається в центр поля з новим напрямком руху,
  - обидві ракетки повертаються в стартові позиції.
- Рахунок відображається у верхній частині екрана великими цифрами.


---
ООП: інкапсуляція, наслідування,поліморфізм

Інкапсуляція - Кожен клас приховує свій внутрішній стан і деталі реалізації

Наслідування -
Створено базовий абстрактний тип ігрового об’єкта. Від нього наслідуються конкретні сутності гри – м’яч та ракетки. Це дозволяє описати спільну поведінку (оновлення стану та відмальовка) один раз, а потім розширювати її в похідних класах.
Для керування ракетками використано окрему ієрархію стратегій: є базовий інтерфейс «стратегія керування», від якого наслідуються страте

Поліморфізм -
Усі ігрові об’єкти зберігаються у векторі як базовий тип (спільний інтерфейс), і в ігровому циклі для них викликаються методи оновлення та відмальовки через віртуальні функції. Гра не «знає», чи це м’яч, чи ракетка, — вона працює з ними поліморфно.
Для ракеток також використано поліморфізм через стратегії керування: ракетка звертається до абстрактної стратегії, а реальна поведінка (гравець чи AI) підставляється у вигляді конкретної реалізації. Це дозволяє змінювати спосіб керування без зміни коду самої ракетки.

---

У проєкті активно використовуються можливості стандартної бібліотеки C++ (STL), зокрема:

std::vector
Використовується для зберігання всіх ігрових об’єктів у вигляді вектора GameObject-ів.

std::shared_ptr
Використовується для зберігання основних ігрових сутностей (м’яч, ракетки) і одночасно їхнього представлення як GameObject у векторі.

std::unique_ptr
Кожна ракетка зберігає стратегію керування як std::unique_ptr, оскільки ця стратегія належить тільки конкретній ракетці й не розділяється з іншими об’єктами.

---

Архітектура ігрового рушія: ігровий цикл, події та відмальовка

У проєкті реалізовано класичний підхід до побудови простого ігрового рушія.
Є окремий клас, який відповідає за керування всією грою та життєвим циклом:
- створення вікна,
- обробка подій,
- оновлення логіки,
- відмальовка кадрів.

Усередині нього організовано постійний ігровий цикл:
обробка подій → оновлення стану гри → відмальовка




Обробка подій (events)
У виділеному методі обробляються події вікна та клавіатури:
- натискання клавіш,
- закриття вікна,
- натискання Escape тощо.
На цьому етапі **немає логіки руху м’яча чи ракеток** — лише реакція на зовнішні події від користувача та системи.




Оновлення логіки гри (update)
В окремому методі виконується все, що стосується **ігрового стану**:
- оновлення всіх ігрових об’єктів (м’яч, ракетки) з урахуванням `dt` (часу між кадрами);
- обробка колізій між м’ячем і ракетками;
- логіка голів (коли м’яч вилітає за межі поля, скидання раунду, оновлення рахунку);
- оновлення тексту рахунку, який буде показано на екрані.
На цьому етапі гра **тільки рахує і змінює стан**, але ще нічого не малює.




Відмальовка (render)
У методі відмальовки:
- очищується екран;
- викликається рендер усіх ігрових об’єктів (через спільний інтерфейс `GameObject`);
- поверх усього відображається текст рахунку;
- фінально кадр виводиться на екран.
Тут немає жодної логіки руху або зміни стану — тільки **рендер поточного результату**. Такий поділ на події, логіку й відмальовку спрощує підтримку та розвиток гри.


---

Патерн Strategy

Я вирішив використати цей патерн проєктування, тому що в моїй грі не потрібно створювати різні типи ракеток, а потрібно гнучко змінювати їхню поведінку (керування з клавіатури чи AI): замість того, щоб зашивати логіку керування всередину класу ракетки, я виніс її в окремі стратегії, і тепер ракетка просто звертається до об’єкта-стратегії за напрямком руху, що дозволяє легко підмінювати або розширювати поведінку без змін у самому класі ракетки.

---

по приколу вирішив додати std::cout << '\a' << std::flush;




